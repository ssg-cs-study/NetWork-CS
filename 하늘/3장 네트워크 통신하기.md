### 3장 네트워크 통신하기

네트워크에서 출발지에서 목적지로 데이터를 전송할 때 사용하는 통신 방식에는 유니캐스트, 브로드캐스트, 멀티캐스트, 애니캐스트가 있음

![Untitled](https://github.com/ssg-cs-study/NetWork-CS/assets/136298009/81911dd0-e406-4181-a7b4-83f2612216ef)


- 유니캐스트 (출발지와 목적지가 정확해야 함
- ex) 웹 트래픽, 이메일, 파일 전송 등)

1:1 통신

가장 많이 사용하는 방식

한 개의 목적지 MAC 주소를 사용하고 CPU 성능에 문제를 주지 않음

- 브로드캐스트 ex) 아파트 관리사무소 방송

1:모든 통신

즉, 로컬 네트워크에 연결되어 있는 모든 시스템에게 프레임을 보내는 방식

모든 시스템에게 패킷이 전송되므로 트래픽이 증가하고 CPU도 패킷을 처리해야 하므로 성능 저하가 발생함

브로드캐스트 방식은 통신하고자 하는 시스템의 MAC 주소를 알지 못하는 경우, 네트워크에 있는 모든 시스템에게 알리는 경우, 라우터끼리 정보를 교환하거나 새로운 라우터를 찾는 경우에 이용

- 멀티캐스트

1:그룹(멀티캐스트 구독 호스트)

연결되어 있는 시스템 중 일부에게만 정보를 전송하는 것

멀티캐스트의 경우 라우터가 멀티캐스트를 지원해야 사용 가능함

유니캐스트의 경우 여러 명에게 보낼 경우 MAC 주소를 모두 확인하여 같은 걸 여러 번 보내야 하는데 수량이 많을수록 네트워크 부하가 커지고 브로드캐스트의 경우 네트워크 전체에 전송이 되니 관련없는 PC에서는 CPU 사용률이 증가하는 문제점이 발생

일반적으로 TCP/IP 상의 인터넷 응용 프로그램은 데이터의 송신자가 이를 수신할 수신자의 인터넷 주소를 전송 패킷의 헤더에 표시해 패킷을 전송함 그러나 멀티캐스트 전송을 위해서는 헤더에 수신자의 주소 대신 수신자들이 참여하고 있는 그룹 주소를 표시하여 패킷을 전송

- 애니캐스트

네트워크에 연결된 수신 가능한 노드 중에서 한 노드에만 데이터를 전송하는데, 이것도 가장 가까운 노드에만 전송함

애니캐스트의 목적은 트래픽 분산, 네트워크 이중화, DDos 공격이 발생했을 때 서버가 받는 피해 최소화, client와 serve간의 물리적인 거리를 줄임으로써 응답 시간을 최소화

네트워크 간 통신을 하기 위해 프로토콜 즉 일종의 약속, 규약이 필요한데 서로의 양식에 맞춰 통신을 해야 한다.

ex) 우리가 택배를 보낼 때 보내는 곳과 받는 곳의 송장을 작성하고 전화를 걸 때에는 전화번호 등의 양식이 있는데, 이런 양식과 같은 규약이 바로 프로토콜 !

가까운 곳과 통신 : 이더넷(MAC 주소)

먼 곳과 통신 : ICMP, IPv4, ARP, IP주소

여러 프로그램과 통신 : TCP, UDP

여러 프로토콜로 캡슐화된 패킷으로 노드들 간에 통신하는데 이걸 캡슐라이징이라 칭함

![Untitled (1)](https://github.com/ssg-cs-study/NetWork-CS/assets/136298009/187f4739-e1d2-424c-b049-668a9a72c1d0)


IPv4는 어느 지역에 있는 노드와 통신해야 하는지

이더넷은 어떤 노드와 통신해야 하는지

TCP는 어떤 프로그램과 통신해야 하는지

- MAC 주소

컴퓨터 간 데이터를 전송하기 위한 컴퓨터의 물리적 주소

IP주소 간의 통신은 사실 각 라우터 hop에서 일어나는 MAC주소 간의 연속적인 과정임

총 48비트로 앞과 뒤 24비트씩 구성됨

01-02-03-A1-B2-C3

0~3까지는 OUI 제조사가 할당하는 부분

A~3까지는 UAA 각 제조사에서 네트워크 구성 요소에 할당하는 부분

BIA(Burned-in Address)라고도 불림

→ MAC주소 동작

NIC는 자신의 MAC주소를 가지고 있고 전기 신호가 들어오면 2계층에서 데이터 형태(패킷)로 변환하여 내용을 구분한 후 도착지 MAC 주소를 확인함

이후 패킷의 목적지 주소 = 자기 자신 or 브로드캐스트, 멀티캐스트와 같은 그룹 주소 → 처리해야 할 주소로 패킷 정보를 상위 계층으로 전달

패킷의 목적지 주소 =/= NIC 카드의 MAC 주소 →  동일하지 않다면 패킷을 페기함

NIC와 LAN 카드는 같은 것이라 생각하면 됨

cf) MAC주소는 단말의 고유한 주소라고 하는데 왜 여러 개인가요?

멀티레이어 스위치, 라우터와 같은 복잡한 네트워크 장비는 NIC가 여러 개이기 때문에 MAC주소도 여러 개가 할당됨

- IP주소

3계층에서 사용하는 논리적 주소

우리가 흔히 사용하는 IP주소는 32비트인 IPv4

IPv6은 128비트임

IPv4주소를 표기할 때는 옥텟이라고 불리는 8비트 단위로 나누고 각 옥텟은 ‘.’으로 구분. 8비트의 옥텟은 0~255의 값을 쓸 수 있음

![Untitled (2)](https://github.com/ssg-cs-study/NetWork-CS/assets/136298009/d94875e9-a58b-4e3d-9922-b5b4d53378af)


네트워크 주소 부문과 호스트 주소 부문으로 나누어짐

MAC 주소의 경우 24비트씩 고정되어 있지만, IP주소는 이 둘을 구분하는 경계점이 고정되어 있지 않음

필요한 호스트 IP 개수에 따라 네트워크의 크기를 다르게 할당하는 클래스 개념이 도입됨

![Untitled (3)](https://github.com/ssg-cs-study/NetWork-CS/assets/136298009/3af14aca-bb2f-47fb-b9a3-12e5eec69917)


A클래스는 첫 번째 옥텟에 네트워크 주소와 호스트 주소를 나누는 구분자가 있음. B클래스는 두 번째, C클래스는 세 번째 → 구분자를 서브넷 마스크라고 함

[쉽게 이해하는 네트워크 13. IP 주소 의미와 체계 및 서브넷 마스크](https://better-together.tistory.com/118)

- 클래스풀 vs 클래스리스

**클래스풀** : 클래스 개념을 도입한 것이 확장성 있고 주소 낭비가 적은 최적의 조건을 만들 수 있는 최적의 선택이었음 → 네트워크 주소와 호스트 주소를 구분짓는 구분자, 즉 서브넷 마스크가 필요 없었음. 맨 앞자리 수만 보면 자연스럽게 이 주소가 어느 클래스에 속해있는지 알 수 있었기 때문 !

**클래스리스** :  IP 주소 낭비가 심한 클래스풀 방법 대신 클래스리스 방법을 사용. 클래스풀처럼 앞자리를 보고 클래스를 확인할 수 없기 때문에 어느 클래스에 속해있는지 모름 → 네트워크와 호스트 주소를 구분하기 위해 서브넷 마스크를 사용

서브넷 마스크 : 숫자 1은 네트워크 주소. 숫자 0은 호스트 주소. 보통은 우리가 편하게 받아들일 수 있는 10진수로 표기하는데, 255는 네트워크 주소. 0은 호스트 주소

ex) IP 주소 : 103.9.32.146

서브넷 마스크 : 255.255.255.0

그럼 네트워크 주소는 103.9.32.0이고

호스트 주소는 0.0.0.146임

- TCP와 UDP

4계층에서 동작하는 프로토콜은 아이피주소와 맥주소와는 만들어진 목적이 조금 다름

→ 통신해야 할 목적지 프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합하여 원래 데이터를 잘 만들어내기 위함

![Untitled (4)](https://github.com/ssg-cs-study/NetWork-CS/assets/136298009/ec420bc4-fcdf-4b05-9d59-b8df7ab8a752)


<좌 TCP / 우 UDP>

![Untitled (5)](https://github.com/ssg-cs-study/NetWork-CS/assets/136298009/77630b78-7829-46f3-bf3e-9aefcf1f7334)


1) TCP (연결 지향 방식)

신뢰할 수 없는 공용망에서도 정보유실이 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된 패킷이 잘 전송되었는지 확인하는 기능

패킷에 번호를 부여 → 잘 전송되었는지 응답

+ 한꺼번에 얼마나 보내야 수신자가 잘 받아 처리할 수 있을지 전송 크기까지 고려함

높은 신뢰성, UDP보다 속도 느림

2) UDP (비연결형 프로토콜)

데이터를 데이터그램 단위로 처리하는 프로토콜

연결 설정하고 해제하는 과정이 존재하지 않기 때문에 패킷에 순서를 부여하여 재조립하거나 흐름제어 또는 혼잡제어와 같은 기능도 처리하지 않음

정보를 주고 받을 때 정보를 보내고, 받는다는 신호 절차를 거치지 않으며 신뢰성이 낮음. TCP보다 속도가 빠름

그래서 신뢰성보다는 연속성이 중요한 서비스 즉 스트리밍 서비스에 자주 이용됨
